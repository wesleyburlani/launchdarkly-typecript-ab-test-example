{"version":3,"file":"ldclient-common.cjs.js","sources":["../src/errors.js","../node_modules/base64-js/index.js","../node_modules/fast-deep-equal/index.js","../src/utils.js","../node_modules/uuid/lib/bytesToUuid.js","../node_modules/uuid/lib/rng-browser.js","../node_modules/uuid/v1.js","../src/EventSender.js","../src/EventSummarizer.js","../src/UserFilter.js","../src/messages.js","../src/EventProcessor.js","../src/EventEmitter.js","../src/InitializationState.js","../src/Store.js","../src/Stream.js","../src/promiseCoalescer.js","../src/Requestor.js","../src/Identity.js","../src/UserValidator.js","../src/configuration.js","../src/diagnosticEvents.js","../src/consoleLogger.js","../src/index.js"],"sourcesContent":["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nexport const LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nexport const LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nexport const LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nexport const LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nexport const LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nexport const LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\n\nexport function isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","import * as base64 from 'base64-js';\nimport fastDeepEqual from 'fast-deep-equal';\n\nconst userAttrsToStringify = ['key', 'secondary', 'ip', 'country', 'email', 'firstName', 'lastName', 'avatar', 'name'];\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nexport function btoa(s) {\n  const escaped = unescape(encodeURIComponent(s));\n  return base64.fromByteArray(stringToBytes(escaped));\n}\n\nfunction stringToBytes(s) {\n  const b = [];\n  for (let i = 0; i < s.length; i++) {\n    b.push(s.charCodeAt(i));\n  }\n  return b;\n}\n\nexport function base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nexport function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function deepEquals(a, b) {\n  return fastDeepEqual(a, b);\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nexport function onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nexport function wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nexport function transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (objectHasOwnProperty(flags, key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nexport function transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (objectHasOwnProperty(flagsState, key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\n/**\n * Returns an array of event groups each of which can be safely URL-encoded\n * without hitting the safe maximum URL length of certain browsers.\n *\n * @param {number} maxLength maximum URL length targeted\n * @param {Array[Object}]} events queue of events to divide\n * @returns Array[Array[Object]]\n */\nexport function chunkUserEventsForUrl(maxLength, events) {\n  const allEvents = events.slice(0);\n  const allChunks = [];\n  let remainingSpace = maxLength;\n  let chunk;\n\n  while (allEvents.length > 0) {\n    chunk = [];\n\n    while (remainingSpace > 0) {\n      const event = allEvents.shift();\n      if (!event) {\n        break;\n      }\n      remainingSpace = remainingSpace - base64URLEncode(JSON.stringify(event)).length;\n      // If we are over the max size, put this one back on the queue\n      // to try in the next round, unless this event alone is larger\n      // than the limit, in which case, screw it, and try it anyway.\n      if (remainingSpace < 0 && chunk.length > 0) {\n        allEvents.unshift(event);\n      } else {\n        chunk.push(event);\n      }\n    }\n\n    remainingSpace = maxLength;\n    allChunks.push(chunk);\n  }\n\n  return allChunks;\n}\n\nexport function getLDUserAgentString(platform) {\n  const version = platform.version || VERSION;\n  return platform.userAgent + '/' + version;\n}\n\nexport function getLDHeaders(platform, options) {\n  if (options && !options.sendLDHeaders) {\n    return {};\n  }\n  const h = {\n    'X-LaunchDarkly-User-Agent': getLDUserAgentString(platform),\n  };\n  if (options && options.wrapperName) {\n    h['X-LaunchDarkly-Wrapper'] = options.wrapperVersion\n      ? options.wrapperName + '/' + options.wrapperVersion\n      : options.wrapperName;\n  }\n  return h;\n}\n\nexport function extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n\nexport function objectHasOwnProperty(object, name) {\n  return Object.prototype.hasOwnProperty.call(object, name);\n}\n\nexport function sanitizeUser(user) {\n  if (!user) {\n    return user;\n  }\n  let newUser;\n  for (const i in userAttrsToStringify) {\n    const attr = userAttrsToStringify[i];\n    const value = user[attr];\n    if (value !== undefined && typeof value !== 'string') {\n      newUser = newUser || { ...user };\n      newUser[attr] = String(value);\n    }\n  }\n  return newUser || user;\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","import * as errors from './errors';\nimport * as utils from './utils';\nimport uuidv1 from 'uuid/v1';\n\nconst MAX_URL_LENGTH = 2000;\n\nexport default function EventSender(platform, environmentId, options) {\n  const imageUrlPath = '/a/' + environmentId + '.gif';\n  const baseHeaders = utils.extend({ 'Content-Type': 'application/json' }, utils.getLDHeaders(platform, options));\n  const httpFallbackPing = platform.httpFallbackPing; // this will be set for us if we're in the browser SDK\n  const sender = {};\n\n  function getResponseInfo(result) {\n    const ret = { status: result.status };\n    const dateStr = result.header('date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  sender.sendChunk = (events, url, isDiagnostic, usePost) => {\n    const jsonBody = JSON.stringify(events);\n    const payloadId = isDiagnostic ? null : uuidv1();\n\n    function doPostRequest(canRetry) {\n      const headers = isDiagnostic\n        ? baseHeaders\n        : utils.extend({}, baseHeaders, {\n            'X-LaunchDarkly-Event-Schema': '3',\n            'X-LaunchDarkly-Payload-ID': payloadId,\n          });\n      return platform\n        .httpRequest('POST', url, headers, jsonBody)\n        .promise.then(result => {\n          if (!result) {\n            // This was a response from a fire-and-forget request, so we won't have a status.\n            return;\n          }\n          if (result.status >= 400 && errors.isHttpErrorRecoverable(result.status) && canRetry) {\n            return doPostRequest(false);\n          } else {\n            return getResponseInfo(result);\n          }\n        })\n        .catch(() => {\n          if (canRetry) {\n            return doPostRequest(false);\n          }\n          return Promise.reject();\n        });\n    }\n\n    if (usePost) {\n      return doPostRequest(true).catch(() => {});\n    } else {\n      httpFallbackPing && httpFallbackPing(url + imageUrlPath + '?d=' + utils.base64URLEncode(jsonBody));\n      return Promise.resolve(); // we don't wait for this request to complete, it's just a one-way ping\n    }\n  };\n\n  sender.sendEvents = function(events, url, isDiagnostic) {\n    if (!platform.httpRequest) {\n      return Promise.resolve();\n    }\n    const canPost = platform.httpAllowsPost();\n    let chunks;\n    if (canPost) {\n      // no need to break up events into chunks if we can send a POST\n      chunks = [events];\n    } else {\n      chunks = utils.chunkUserEventsForUrl(MAX_URL_LENGTH - url.length, events);\n    }\n    const results = [];\n    for (let i = 0; i < chunks.length; i++) {\n      results.push(sender.sendChunk(chunks[i], url, isDiagnostic, canPost));\n    }\n    return Promise.all(results);\n  };\n\n  return sender;\n}\n","export default function EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {};\n\n  es.summarizeEvent = function(event) {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          variation: event.variation,\n          version: event.version,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = function() {\n    const flagsOut = {};\n    let empty = true;\n    for (const i in counters) {\n      const c = counters[i];\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n        };\n  };\n\n  es.clearSummary = function() {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n  };\n\n  return es;\n}\n","import * as utils from './utils';\n\n/**\n * The UserFilter object transforms user objects into objects suitable to be sent as JSON to\n * the server, hiding any private user attributes.\n *\n * @param {Object} the LaunchDarkly client configuration object\n **/\nexport default function UserFilter(config) {\n  const filter = {};\n  const allAttributesPrivate = config.allAttributesPrivate;\n  const privateAttributeNames = config.privateAttributeNames || [];\n  const ignoreAttrs = { key: true, custom: true, anonymous: true };\n  const allowedTopLevelAttrs = {\n    key: true,\n    secondary: true,\n    ip: true,\n    country: true,\n    email: true,\n    firstName: true,\n    lastName: true,\n    avatar: true,\n    name: true,\n    anonymous: true,\n    custom: true,\n  };\n\n  filter.filterUser = function(user) {\n    if (!user) {\n      return null;\n    }\n    const userPrivateAttrs = user.privateAttributeNames || [];\n\n    const isPrivateAttr = function(name) {\n      return (\n        !ignoreAttrs[name] &&\n        (allAttributesPrivate || userPrivateAttrs.indexOf(name) !== -1 || privateAttributeNames.indexOf(name) !== -1)\n      );\n    };\n    const filterAttrs = function(props, isAttributeAllowed) {\n      return Object.keys(props).reduce(\n        (acc, name) => {\n          const ret = acc;\n          if (isAttributeAllowed(name)) {\n            if (isPrivateAttr(name)) {\n              // add to hidden list\n              ret[1][name] = true;\n            } else {\n              ret[0][name] = props[name];\n            }\n          }\n          return ret;\n        },\n        [{}, {}]\n      );\n    };\n    const result = filterAttrs(user, key => allowedTopLevelAttrs[key]);\n    const filteredProps = result[0];\n    let removedAttrs = result[1];\n    if (user.custom) {\n      const customResult = filterAttrs(user.custom, () => true);\n      filteredProps.custom = customResult[0];\n      removedAttrs = utils.extend({}, removedAttrs, customResult[1]);\n    }\n    const removedAttrNames = Object.keys(removedAttrs);\n    if (removedAttrNames.length) {\n      removedAttrNames.sort();\n      filteredProps.privateAttrs = removedAttrNames;\n    }\n    return filteredProps;\n  };\n  return filter;\n}\n","import * as errors from './errors';\n\nfunction errorString(err) {\n  if (err && err.message) {\n    return err.message;\n  }\n  if (typeof err === 'string' || err instanceof String) {\n    return err;\n  }\n  return JSON.stringify(err);\n}\n\nexport const clientInitialized = function() {\n  return 'LaunchDarkly client initialized';\n};\n\nconst docLink =\n  ' Please see https://docs.launchdarkly.com/docs/js-sdk-reference#section-initializing-the-client for instructions on SDK initialization.';\n\nexport const clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nexport const eventCapacityExceeded = function() {\n  return 'Exceeded event queue capacity. Increase capacity to avoid dropping events.';\n};\n\nexport const eventWithoutUser = function() {\n  return 'Be sure to call `identify` in the LaunchDarkly client: https://docs.launchdarkly.com/docs/js-sdk-reference#section-analytics-events';\n};\n\nexport const invalidContentType = function(contentType) {\n  return 'Expected application/json content type but got \"' + contentType + '\"';\n};\n\nexport const invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nexport const localStorageUnavailable = function() {\n  return 'localStorage is unavailable';\n};\n\nexport const localStorageUnavailableForUserId = function() {\n  return 'localStorage is unavailable, so anonymous user ID cannot be cached';\n};\n\nexport const networkError = e => 'network error' + (e ? ' (' + e + ')' : '');\n\nexport const unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nexport const environmentNotFound = function() {\n  return 'Environment not found. Double check that you specified a valid environment/client-side ID.' + docLink;\n};\n\nexport const environmentNotSpecified = function() {\n  return 'No environment/client-side ID was specified.' + docLink;\n};\n\nexport const errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + errorString(err);\n};\n\nexport const userNotSpecified = function() {\n  return 'No user specified.' + docLink;\n};\n\nexport const invalidUser = function() {\n  return 'Invalid user specified.' + docLink;\n};\n\nexport const bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nexport const bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nexport const deprecated = function(oldName, newName) {\n  if (newName) {\n    return '\"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n  }\n  return '\"' + oldName + '\" is deprecated';\n};\n\nexport const httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n\nexport const httpUnavailable = function() {\n  return 'Cannot make HTTP requests in this environment.' + docLink;\n};\n\nexport const identifyDisabled = function() {\n  return 'identify() has no effect here; it must be called on the main client instance';\n};\n\nexport const streamClosing = function() {\n  return 'Closing stream connection';\n};\n\nexport const streamConnecting = function(url) {\n  return 'Opening stream connection to ' + url;\n};\n\nexport const streamError = function(err, streamReconnectDelay) {\n  return (\n    'Error on stream connection: ' +\n    errorString(err) +\n    ', will continue retrying every ' +\n    streamReconnectDelay +\n    ' milliseconds.'\n  );\n};\n\nexport const unknownOption = name => 'Ignoring unknown config option \"' + name + '\"';\n\nexport const wrongOptionType = (name, expectedType, actualType) =>\n  'Config option \"' + name + '\" should be of type ' + expectedType + ', got ' + actualType + ', using default value';\n\nexport const wrongOptionTypeBoolean = (name, actualType) =>\n  'Config option \"' + name + '\" should be a boolean, got ' + actualType + ', converting to boolean';\n\nexport const optionBelowMinimum = (name, value, minimum) =>\n  'Config option \"' + name + '\" was set to ' + value + ', changing to minimum value of ' + minimum;\n\nexport const debugPolling = function(url) {\n  return 'polling for feature flags at ' + url;\n};\n\nexport const debugStreamPing = function() {\n  return 'received ping message from stream';\n};\n\nexport const debugStreamPut = function() {\n  return 'received streaming update for all flags';\n};\n\nexport const debugStreamPatch = function(key) {\n  return 'received streaming update for flag \"' + key + '\"';\n};\n\nexport const debugStreamPatchIgnored = function(key) {\n  return 'received streaming update for flag \"' + key + '\" but ignored due to version check';\n};\n\nexport const debugStreamDelete = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\"';\n};\n\nexport const debugStreamDeleteIgnored = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\" but ignored due to version check';\n};\n\nexport const debugEnqueueingEvent = function(kind) {\n  return 'enqueueing \"' + kind + '\" event';\n};\n\nexport const debugPostingEvents = function(count) {\n  return 'sending ' + count + ' events';\n};\n\nexport const debugPostingDiagnosticEvent = function(event) {\n  return 'sending diagnostic event (' + event.kind + ')';\n};\n","import EventSender from './EventSender';\nimport EventSummarizer from './EventSummarizer';\nimport UserFilter from './UserFilter';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function EventProcessor(\n  platform,\n  options,\n  environmentId,\n  diagnosticsAccumulator = null,\n  emitter = null,\n  sender = null\n) {\n  const processor = {};\n  const eventSender = sender || EventSender(platform, environmentId, options);\n  const mainEventsUrl = options.eventsUrl + '/events/bulk/' + environmentId;\n  const summarizer = EventSummarizer();\n  const userFilter = UserFilter(options);\n  const inlineUsers = options.inlineUsersInEvents;\n  const samplingInterval = options.samplingInterval;\n  const eventCapacity = options.eventCapacity;\n  const flushInterval = options.flushInterval;\n  const logger = options.logger;\n  let queue = [];\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let exceededCapacity = false;\n  let flushTimer;\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n    if (inlineUsers || e.kind === 'identify') {\n      // identify events always have an inline user\n      ret.user = userFilter.filterUser(e.user);\n    } else {\n      ret.userKey = e.user.key;\n      delete ret['user'];\n    }\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  function addToOutbox(event) {\n    if (queue.length < eventCapacity) {\n      queue.push(event);\n      exceededCapacity = false;\n    } else {\n      if (!exceededCapacity) {\n        exceededCapacity = true;\n        logger.warn(messages.eventCapacityExceeded());\n      }\n      if (diagnosticsAccumulator) {\n        // For diagnostic events, we track how many times we had to drop an event due to exceeding the capacity.\n        diagnosticsAccumulator.incrementDroppedEvents();\n      }\n    }\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      addToOutbox(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      delete debugEvent['variation'];\n      addToOutbox(debugEvent);\n    }\n  };\n\n  processor.flush = function() {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summary = summarizer.getSummary();\n    summarizer.clearSummary();\n    if (summary) {\n      summary.kind = 'summary';\n      eventsToSend.push(summary);\n    }\n    if (diagnosticsAccumulator) {\n      // For diagnostic events, we record how many events were in the queue at the last flush (since \"how\n      // many events happened to be in the queue at the moment we decided to send a diagnostic event\" would\n      // not be a very useful statistic).\n      diagnosticsAccumulator.setEventsInLastBatch(eventsToSend.length);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    logger.debug(messages.debugPostingEvents(eventsToSend.length));\n    return eventSender.sendEvents(eventsToSend, mainEventsUrl).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n","export default function EventEmitter(logger) {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    // Copy the list of handlers before iterating, in case any handler adds or removes another handler.\n    // Any such changes should not affect what we do here-- we want to notify every handler that existed\n    // at the moment that the event was fired.\n    const copiedHandlers = events[event].slice(0);\n    for (let i = 0; i < copiedHandlers.length; i++) {\n      copiedHandlers[i].handler.apply(copiedHandlers[i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.getEvents = function() {\n    return Object.keys(events);\n  };\n\n  emitter.getEventListenerCount = function(event) {\n    return events[event] ? events[event].length : 0;\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      (logger || console).error(error.message);\n    }\n  };\n  return emitter;\n}\n","// This file provides an abstraction of the client's startup state.\n//\n// Startup can either succeed or fail exactly once; calling signalSuccess() or signalFailure()\n// after that point has no effect.\n//\n// On success, we fire both an \"initialized\" event and a \"ready\" event. Both the waitForInitialization()\n// promise and the waitUntilReady() promise are resolved in this case.\n//\n// On failure, we fire both a \"failed\" event (with the error as a parameter) and a \"ready\" event.\n// The waitForInitialization() promise is rejected, but the waitUntilReady() promise is resolved.\n//\n// To complicate things, we must *not* create the waitForInitialization() promise unless it is\n// requested, because otherwise failures would cause an *unhandled* rejection which can be a\n// serious problem in some environments. So we use a somewhat roundabout system for tracking the\n// initialization state and lazily creating this promise.\n\nconst readyEvent = 'ready',\n  successEvent = 'initialized',\n  failureEvent = 'failed';\n\nfunction InitializationStateTracker(eventEmitter) {\n  let succeeded = false,\n    failed = false,\n    failureValue = null,\n    initializationPromise = null;\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = () => {\n      eventEmitter.off(readyEvent, onReady); // we can't use \"once\" because it's not available on some JS platforms\n      resolve();\n    };\n    eventEmitter.on(readyEvent, onReady);\n  }).catch(() => {}); // this Promise should never be rejected, but the catch handler is a safety measure\n\n  return {\n    getInitializationPromise: () => {\n      if (initializationPromise) {\n        return initializationPromise;\n      }\n      if (succeeded) {\n        return Promise.resolve();\n      }\n      if (failed) {\n        return Promise.reject(failureValue);\n      }\n      initializationPromise = new Promise((resolve, reject) => {\n        const onSuccess = () => {\n          eventEmitter.off(successEvent, onSuccess);\n          resolve();\n        };\n        const onFailure = err => {\n          eventEmitter.off(failureEvent, onFailure);\n          reject(err);\n        };\n        eventEmitter.on(successEvent, onSuccess);\n        eventEmitter.on(failureEvent, onFailure);\n      });\n      return initializationPromise;\n    },\n\n    getReadyPromise: () => readyPromise,\n\n    signalSuccess: () => {\n      if (!succeeded && !failed) {\n        succeeded = true;\n        eventEmitter.emit(successEvent);\n        eventEmitter.emit(readyEvent);\n      }\n    },\n\n    signalFailure: err => {\n      if (!succeeded && !failed) {\n        failed = true;\n        failureValue = err;\n        eventEmitter.emit(failureEvent, err);\n        eventEmitter.emit(readyEvent);\n      }\n      eventEmitter.maybeReportError(err); // the \"error\" event can be emitted more than once, unlike the others\n    },\n  };\n}\n\nmodule.exports = InitializationStateTracker;\n","import * as messages from './messages';\nimport * as utils from './utils';\n\n// The localStorageProvider is provided by the platform object. It should have the following\n// methods, each of which should return a Promise:\n// - get(key): Gets the string value, if any, for the given key\n// - set(key, value): Stores a string value for the given key\n// - remove(key): Removes the given key\nexport default function Store(localStorageProvider, environment, hash, ident, logger) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const user = ident.getUser();\n    if (user) {\n      key = hash || utils.btoa(JSON.stringify(user));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  // Returns a Promise which will be resolved with a parsed JSON value if a stored value was available,\n  // resolved with null if there was no value, or rejected if storage was not available.\n  store.loadFlags = () =>\n    localStorageProvider\n      .get(getFlagsKey())\n      .then(dataStr => {\n        if (dataStr === null || dataStr === undefined) {\n          return null;\n        }\n        try {\n          let data = JSON.parse(dataStr);\n          if (data) {\n            const schema = data.$schema;\n            if (schema === undefined || schema < 1) {\n              data = utils.transformValuesToVersionedValues(data);\n            } else {\n              delete data['$schema'];\n            }\n          }\n          return data;\n        } catch (ex) {\n          return store.clearFlags().then(() => Promise.reject(ex));\n        }\n      })\n      .catch(err => {\n        logger.warn(messages.localStorageUnavailable());\n        return Promise.reject(err);\n      });\n\n  // Returns a Promise which will be resolved with no value if successful, or rejected if storage\n  // was not available.\n  store.saveFlags = flags => {\n    const data = utils.extend({}, flags, { $schema: 1 });\n    return localStorageProvider.set(getFlagsKey(), JSON.stringify(data)).catch(err => {\n      logger.warn(messages.localStorageUnavailable());\n      return Promise.reject(err);\n    });\n  };\n\n  // Returns a Promise which will be resolved with no value if successful, or rejected if storage\n  // was not available.\n  store.clearFlags = () =>\n    localStorageProvider.clear(getFlagsKey()).catch(err => {\n      logger.warn(messages.localStorageUnavailable());\n      return Promise.reject(err);\n    });\n\n  return store;\n}\n","import * as messages from './messages';\nimport { base64URLEncode, getLDHeaders, objectHasOwnProperty } from './utils';\n\n// The underlying event source implementation is abstracted via the platform object, which should\n// have these three properties:\n// eventSourceFactory(): a function that takes a URL and optional request body and returns an object\n//   with the same methods as the regular HTML5 EventSource object. Passing a body parameter means\n//   that the request should use REPORT instead of GET.\n// eventSourceIsActive(): a function that takes an EventSource-compatible object and returns true if\n//   it is in an active state (connected or connecting).\n// eventSourceAllowsReport: true if REPORT is supported.\n\nexport default function Stream(platform, config, environment, diagnosticsAccumulator) {\n  const baseUrl = config.streamUrl;\n  const logger = config.logger;\n  const stream = {};\n  const evalUrlPrefix = baseUrl + '/eval/' + environment;\n  const useReport = config.useReport;\n  const withReasons = config.evaluationReasons;\n  const streamReconnectDelay = config.streamReconnectDelay;\n  const headers = getLDHeaders(platform, config);\n  let firstConnectionErrorLogged = false;\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let connectionAttemptStartTime;\n  let user = null;\n  let hash = null;\n  let handlers = null;\n\n  stream.connect = function(newUser, newHash, newHandlers) {\n    user = newUser;\n    hash = newHash;\n    handlers = {};\n    for (const key in newHandlers || {}) {\n      handlers[key] = function(e) {\n        // Reset the state for logging the first connection error so that the first\n        // connection error following a successful connection will once again be logged.\n        // We will decorate *all* handlers to do this to keep this abstraction agnostic\n        // for different stream implementations.\n        firstConnectionErrorLogged = false;\n        logConnectionResult(true);\n        newHandlers[key] && newHandlers[key](e);\n      };\n    }\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    closeConnection();\n  };\n\n  stream.isConnected = function() {\n    return !!(es && platform.eventSourceIsActive && platform.eventSourceIsActive(es));\n  };\n\n  function handleError(err) {\n    if (!firstConnectionErrorLogged) {\n      logger.warn(messages.streamError(err, streamReconnectDelay));\n      firstConnectionErrorLogged = true;\n    }\n    logConnectionResult(false);\n    closeConnection();\n    tryConnect(streamReconnectDelay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    reconnectTimeoutReference = null;\n    let url;\n    let query = '';\n    const options = { headers };\n    if (platform.eventSourceFactory) {\n      if (hash !== null && hash !== undefined) {\n        query = 'h=' + hash;\n      }\n      if (useReport) {\n        if (platform.eventSourceAllowsReport) {\n          url = evalUrlPrefix;\n          options.method = 'REPORT';\n          options.headers['Content-Type'] = 'application/json';\n          options.body = JSON.stringify(user);\n        } else {\n          // if we can't do REPORT, fall back to the old ping-based stream\n          url = baseUrl + '/ping/' + environment;\n          query = '';\n        }\n      } else {\n        url = evalUrlPrefix + '/' + base64URLEncode(JSON.stringify(user));\n      }\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n      logger.info(messages.streamConnecting(url));\n      logConnectionStarted();\n\n      es = platform.eventSourceFactory(url, options);\n      for (const key in handlers) {\n        if (objectHasOwnProperty(handlers, key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = handleError;\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      logger.info(messages.streamClosing());\n      es.close();\n      es = null;\n    }\n  }\n\n  function logConnectionStarted() {\n    connectionAttemptStartTime = new Date().getTime();\n  }\n\n  function logConnectionResult(success) {\n    if (connectionAttemptStartTime && diagnosticsAccumulator) {\n      diagnosticsAccumulator.recordStreamInit(\n        connectionAttemptStartTime,\n        !success,\n        new Date().getTime() - connectionAttemptStartTime\n      );\n    }\n    connectionAttemptStartTime = null;\n  }\n\n  return stream;\n}\n","// This function allows a series of Promises to be coalesced such that only the most recently\n// added one actually matters. For instance, if several HTTP requests are made to the same\n// endpoint and we want to ensure that whoever made each one always gets the latest data, each\n// can be passed to addPromise (on the same coalescer) and each caller can wait on the\n// coalescer.resultPromise; all three will then receive the result (or error) from the *last*\n// request, and the results of the first two will be discarded.\n//\n// The cancelFn callback, if present, will be called whenever an existing promise is being\n// discarded. This can be used for instance to abort an HTTP request that's now obsolete.\n//\n// The finallyFn callback, if present, is called on completion of the whole thing. This is\n// different from calling coalescer.resultPromise.finally() because it is executed before any\n// other handlers. Its purpose is to tell the caller that this coalescer should no longer be used.\n\nexport default function promiseCoalescer(finallyFn) {\n  let currentPromise;\n  let currentCancelFn;\n  let finalResolve;\n  let finalReject;\n\n  const coalescer = {};\n\n  coalescer.addPromise = (p, cancelFn) => {\n    currentPromise = p;\n    currentCancelFn && currentCancelFn();\n    currentCancelFn = cancelFn;\n\n    p.then(\n      result => {\n        if (currentPromise === p) {\n          finalResolve(result);\n          finallyFn && finallyFn();\n        }\n      },\n      error => {\n        if (currentPromise === p) {\n          finalReject(error);\n          finallyFn && finallyFn();\n        }\n      }\n    );\n  };\n\n  coalescer.resultPromise = new Promise((resolve, reject) => {\n    finalResolve = resolve;\n    finalReject = reject;\n  });\n\n  return coalescer;\n}\n","import * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport promiseCoalescer from './promiseCoalescer';\n\nconst jsonContentType = 'application/json';\n\nfunction getResponseError(result) {\n  if (result.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return new errors.LDFlagFetchError(messages.errorFetchingFlags(result.statusText || String(result.status)));\n  }\n}\n\nexport default function Requestor(platform, options, environment) {\n  const baseUrl = options.baseUrl;\n  const useReport = options.useReport;\n  const withReasons = options.evaluationReasons;\n  const logger = options.logger;\n\n  const requestor = {};\n\n  const activeRequests = {}; // map of URLs to promiseCoalescers\n\n  function fetchJSON(endpoint, body) {\n    if (!platform.httpRequest) {\n      return new Promise((resolve, reject) => {\n        reject(new errors.LDFlagFetchError(messages.httpUnavailable()));\n      });\n    }\n\n    const method = body ? 'REPORT' : 'GET';\n    const headers = utils.getLDHeaders(platform, options);\n    if (body) {\n      headers['Content-Type'] = jsonContentType;\n    }\n\n    let coalescer = activeRequests[endpoint];\n    if (!coalescer) {\n      coalescer = promiseCoalescer(() => {\n        // this will be called once there are no more active requests for the same endpoint\n        delete activeRequests[endpoint];\n      });\n      activeRequests[endpoint] = coalescer;\n    }\n\n    const req = platform.httpRequest(method, endpoint, headers, body);\n    const p = req.promise.then(\n      result => {\n        if (result.status === 200) {\n          if (result.header('content-type') && result.header('content-type').startsWith(jsonContentType)) {\n            return JSON.parse(result.body);\n          } else {\n            const message = messages.invalidContentType(result.header('content-type') || '');\n            return Promise.reject(new errors.LDFlagFetchError(message));\n          }\n        } else {\n          return Promise.reject(getResponseError(result));\n        }\n      },\n      e => Promise.reject(new errors.LDFlagFetchError(messages.networkError(e)))\n    );\n    coalescer.addPromise(p, () => {\n      // this will be called if another request for the same endpoint supersedes this one\n      req.cancel && req.cancel();\n    });\n    return coalescer.resultPromise;\n  }\n\n  // Performs a GET request to an arbitrary path under baseUrl. Returns a Promise which will resolve\n  // with the parsed JSON response, or will be rejected if the request failed.\n  requestor.fetchJSON = function(path) {\n    return fetchJSON(baseUrl + path, null);\n  };\n\n  // Requests the current state of all flags for the given user from LaunchDarkly. Returns a Promise\n  // which will resolve with the parsed JSON response, or will be rejected if the request failed.\n  requestor.fetchFlagSettings = function(user, hash) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/user'].join('');\n      body = JSON.stringify(user);\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(user));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/users/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n    logger.debug(messages.debugPolling(endpoint));\n\n    return fetchJSON(endpoint, body);\n  };\n\n  return requestor;\n}\n","import * as utils from './utils';\n\nexport default function Identity(initialUser, onChange) {\n  const ident = {};\n  let user;\n\n  ident.setUser = function(u) {\n    user = utils.sanitizeUser(u);\n    if (user && onChange) {\n      onChange(utils.clone(user));\n    }\n  };\n\n  ident.getUser = function() {\n    return user ? utils.clone(user) : null;\n  };\n\n  if (initialUser) {\n    ident.setUser(initialUser);\n  }\n\n  return ident;\n}\n","import uuidv1 from 'uuid/v1';\n\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\n// Transforms the user object if necessary to make sure it has a valid key.\n// 1. If a key is present, but is not a string, change it to a string.\n// 2. If no key is present, and \"anonymous\" is true, use a UUID as a key. This is cached in local\n// storage if possible.\n// 3. If there is no key (or no user object), return an error.\n\nconst ldUserIdKey = 'ld:$anonUserId';\n\nexport default function UserValidator(localStorageProvider, logger) {\n  function getCachedUserId() {\n    if (localStorageProvider) {\n      return localStorageProvider.get(ldUserIdKey).catch(() => null);\n      // Not logging errors here, because if local storage fails for the get, it will presumably fail for the set,\n      // so we will end up logging an error in setCachedUserId anyway.\n    }\n    return Promise.resolve(null);\n  }\n\n  function setCachedUserId(id) {\n    if (localStorageProvider) {\n      return localStorageProvider.set(ldUserIdKey, id).catch(() => {\n        logger.warn(messages.localStorageUnavailableForUserId());\n      });\n    }\n    return Promise.resolve();\n  }\n\n  const ret = {};\n\n  // Validates the user, returning a Promise that resolves to the validated user, or rejects if there is an error.\n  ret.validateUser = user => {\n    if (!user) {\n      return Promise.reject(new errors.LDInvalidUserError(messages.userNotSpecified()));\n    }\n\n    const userOut = utils.clone(user);\n    if (userOut.key !== null && userOut.key !== undefined) {\n      userOut.key = userOut.key.toString();\n      return Promise.resolve(userOut);\n    }\n    if (userOut.anonymous) {\n      return getCachedUserId().then(cachedId => {\n        if (cachedId) {\n          userOut.key = cachedId;\n          return userOut;\n        } else {\n          const id = uuidv1();\n          userOut.key = id;\n          return setCachedUserId(id).then(() => userOut);\n        }\n      });\n    } else {\n      return Promise.reject(new errors.LDInvalidUserError(messages.invalidUser()));\n    }\n  };\n\n  return ret;\n}\n","import * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\n// baseOptionDefs should contain an entry for each supported configuration option in the common package.\n// Each entry can have three properties:\n// - \"default\": the default value if any\n// - \"type\": a type constraint used if the type can't be inferred from the default value). The allowable\n//   values are \"boolean\", \"string\", \"number\", \"array\", \"object\", \"function\", or several of these OR'd\n//   together with \"|\" (\"function|object\").\n// - \"minimum\": minimum value if any for numeric properties\n//\n// The extraOptionDefs parameter to validate() uses the same format.\nexport const baseOptionDefs = {\n  baseUrl: { default: 'https://app.launchdarkly.com' },\n  streamUrl: { default: 'https://clientstream.launchdarkly.com' },\n  eventsUrl: { default: 'https://events.launchdarkly.com' },\n  sendEvents: { default: true },\n  streaming: { type: 'boolean' }, // default for this is undefined, which is different from false\n  sendLDHeaders: { default: true },\n  inlineUsersInEvents: { default: false },\n  allowFrequentDuplicateEvents: { default: false },\n  sendEventsOnlyForVariation: { default: false },\n  useReport: { default: false },\n  evaluationReasons: { default: false },\n  eventCapacity: { default: 100, minimum: 1 },\n  flushInterval: { default: 2000, minimum: 2000 },\n  samplingInterval: { default: 0, minimum: 0 },\n  streamReconnectDelay: { default: 1000, minimum: 0 },\n  allAttributesPrivate: { default: false },\n  privateAttributeNames: { default: [] },\n  bootstrap: { type: 'string|object' },\n  diagnosticRecordingInterval: { default: 900000, minimum: 2000 },\n  diagnosticOptOut: { default: false },\n  wrapperName: { type: 'string' },\n  wrapperVersion: { type: 'string' },\n  stateProvider: { type: 'object' }, // not a public option, used internally\n};\n\nexport function validate(options, emitter, extraOptionDefs, logger) {\n  const optionDefs = utils.extend({ logger: { default: logger } }, baseOptionDefs, extraOptionDefs);\n\n  const deprecatedOptions = {\n    // eslint-disable-next-line camelcase\n    all_attributes_private: 'allAttributesPrivate',\n    // eslint-disable-next-line camelcase\n    private_attribute_names: 'privateAttributeNames',\n    samplingInterval: null,\n  };\n\n  function checkDeprecatedOptions(config) {\n    const opts = config;\n    Object.keys(deprecatedOptions).forEach(oldName => {\n      if (opts[oldName] !== undefined) {\n        const newName = deprecatedOptions[oldName];\n        logger && logger.warn(messages.deprecated(oldName, newName));\n        if (newName) {\n          if (opts[newName] === undefined) {\n            opts[newName] = opts[oldName];\n          }\n          delete opts[oldName];\n        }\n      }\n    });\n  }\n\n  function applyDefaults(config) {\n    // This works differently from utils.extend() in that it *will not* override a default value\n    // if the provided value is explicitly set to null. This provides backward compatibility\n    // since in the past we only used the provided values if they were truthy.\n    const ret = utils.extend({}, config);\n    Object.keys(optionDefs).forEach(name => {\n      if (ret[name] === undefined || ret[name] === null) {\n        ret[name] = optionDefs[name] && optionDefs[name].default;\n      }\n    });\n    return ret;\n  }\n\n  function validateTypesAndNames(config) {\n    const ret = utils.extend({}, config);\n    const typeDescForValue = value => {\n      if (value === null) {\n        return 'any';\n      }\n      if (value === undefined) {\n        return undefined;\n      }\n      if (Array.isArray(value)) {\n        return 'array';\n      }\n      const t = typeof value;\n      if (t === 'boolean' || t === 'string' || t === 'number' || t === 'function') {\n        return t;\n      }\n      return 'object';\n    };\n    Object.keys(config).forEach(name => {\n      const value = config[name];\n      if (value !== null && value !== undefined) {\n        const optionDef = optionDefs[name];\n        if (optionDef === undefined) {\n          reportArgumentError(messages.unknownOption(name));\n        } else {\n          const expectedType = optionDef.type || typeDescForValue(optionDef.default);\n          if (expectedType !== 'any') {\n            const allowedTypes = expectedType.split('|');\n            const actualType = typeDescForValue(value);\n            if (allowedTypes.indexOf(actualType) < 0) {\n              if (expectedType === 'boolean') {\n                ret[name] = !!value;\n                reportArgumentError(messages.wrongOptionTypeBoolean(name, actualType));\n              } else {\n                reportArgumentError(messages.wrongOptionType(name, expectedType, actualType));\n                ret[name] = optionDef.default;\n              }\n            } else {\n              if (actualType === 'number' && optionDef.minimum !== undefined && value < optionDef.minimum) {\n                reportArgumentError(messages.optionBelowMinimum(name, value, optionDef.minimum));\n                ret[name] = optionDef.minimum;\n              }\n            }\n          }\n        }\n      }\n    });\n    return ret;\n  }\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  let config = utils.extend({}, options || {});\n\n  checkDeprecatedOptions(config);\n\n  config = applyDefaults(config);\n  config = validateTypesAndNames(config);\n\n  return config;\n}\n","const uuidv1 = require('uuid/v1');\n// Note that in the diagnostic events spec, these IDs are to be generated with UUID v4. However,\n// in JS we were already using v1 for unique user keys, so to avoid bringing in two packages we\n// will use v1 here as well.\n\nconst { baseOptionDefs } = require('./configuration');\nconst messages = require('./messages');\n\nfunction DiagnosticId(sdkKey) {\n  const ret = {\n    diagnosticId: uuidv1(),\n  };\n  if (sdkKey) {\n    ret.sdkKeySuffix = sdkKey.length > 6 ? sdkKey.substring(sdkKey.length - 6) : sdkKey;\n  }\n  return ret;\n}\n\n// A stateful object holding statistics that will go into diagnostic events.\n\nfunction DiagnosticsAccumulator(startTime) {\n  let dataSinceDate, droppedEvents, eventsInLastBatch, streamInits;\n\n  function reset(time) {\n    dataSinceDate = time;\n    droppedEvents = 0;\n    eventsInLastBatch = 0;\n    streamInits = [];\n  }\n\n  reset(startTime);\n\n  return {\n    getProps: () => ({\n      dataSinceDate,\n      droppedEvents,\n      eventsInLastBatch,\n      streamInits,\n      // omit deduplicatedUsers for the JS SDKs because they don't deduplicate users\n    }),\n    setProps: props => {\n      dataSinceDate = props.dataSinceDate;\n      droppedEvents = props.droppedEvents || 0;\n      eventsInLastBatch = props.eventsInLastBatch || 0;\n      streamInits = props.streamInits || [];\n    },\n    incrementDroppedEvents: () => {\n      droppedEvents++;\n    },\n    setEventsInLastBatch: n => {\n      eventsInLastBatch = n;\n    },\n    recordStreamInit: (timestamp, failed, durationMillis) => {\n      const info = { timestamp, failed, durationMillis };\n      streamInits.push(info);\n    },\n    reset,\n  };\n}\n\n// An object that maintains information that will go into diagnostic events, and knows how to format\n// those events. It is instantiated by the SDK client, and shared with the event processor.\n//\n// The JS-based SDKs have two modes for diagnostic events. By default, the behavior is basically the\n// same as the server-side SDKs: a \"diagnostic-init\" event is sent on startup, and then \"diagnostic\"\n// events with operating statistics are sent periodically. However, in a browser environment this is\n// undesirable because the page may be reloaded frequently. In that case, setting the property\n// \"platform.diagnosticUseCombinedEvent\" to true enables an alternate mode in which a combination of\n// both kinds of event is sent at intervals, relative to the last time this was done (if any) which\n// is cached in local storage.\n\nfunction DiagnosticsManager(platform, accumulator, eventSender, environmentId, config, diagnosticId) {\n  const combinedMode = !!platform.diagnosticUseCombinedEvent;\n  const localStorageKey = 'ld:' + environmentId + ':$diagnostics';\n  const diagnosticEventsUrl = config.eventsUrl + '/events/diagnostic/' + environmentId;\n  const periodicInterval = config.diagnosticRecordingInterval;\n  const acc = accumulator;\n  const initialEventSamplingInterval = 4; // used only in combined mode - see start()\n  let streamingEnabled = !!config.streaming;\n  let eventSentTime;\n  let periodicTimer;\n  const manager = {};\n\n  function makeInitProperties() {\n    return {\n      sdk: makeSdkData(),\n      configuration: makeConfigData(),\n      platform: platform.diagnosticPlatformData,\n    };\n  }\n\n  // Send a diagnostic event and do not wait for completion.\n  function sendDiagnosticEvent(event) {\n    config.logger && config.logger.debug(messages.debugPostingDiagnosticEvent(event));\n    eventSender\n      .sendEvents(event, diagnosticEventsUrl, true)\n      .then(() => undefined)\n      .catch(() => undefined);\n  }\n\n  function loadProperties(callback) {\n    if (!platform.localStorage) {\n      return callback(false); // false indicates that local storage is not available\n    }\n    platform.localStorage\n      .get(localStorageKey)\n      .then(data => {\n        if (data) {\n          try {\n            const props = JSON.parse(data);\n            acc.setProps(props);\n            eventSentTime = props.dataSinceDate;\n          } catch (e) {\n            // disregard malformed cached data\n          }\n        }\n        callback(true);\n      })\n      .catch(() => {\n        callback(false);\n      });\n  }\n\n  function saveProperties() {\n    if (platform.localStorage) {\n      const props = { ...acc.getProps() };\n      platform.localStorage.set(localStorageKey, JSON.stringify(props), () => {});\n    }\n  }\n\n  // Creates the initial event that is sent by the event processor when the SDK starts up. This will not\n  // be repeated during the lifetime of the SDK client. In combined mode, we don't send this.\n  function createInitEvent() {\n    return {\n      kind: 'diagnostic-init',\n      id: diagnosticId,\n      creationDate: acc.getProps().dataSinceDate,\n      ...makeInitProperties(),\n    };\n  }\n\n  // Creates a periodic event containing time-dependent stats, and resets the state of the manager with\n  // regard to those stats. In combined mode (browser SDK) this also contains the configuration data.\n  function createPeriodicEventAndReset() {\n    const currentTime = new Date().getTime();\n    let ret = {\n      kind: combinedMode ? 'diagnostic-combined' : 'diagnostic',\n      id: diagnosticId,\n      creationDate: currentTime,\n      ...acc.getProps(),\n    };\n    if (combinedMode) {\n      ret = { ...ret, ...makeInitProperties() };\n    }\n    acc.reset(currentTime);\n    return ret;\n  }\n\n  function sendPeriodicEvent() {\n    sendDiagnosticEvent(createPeriodicEventAndReset());\n    periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n    eventSentTime = new Date().getTime();\n    if (combinedMode) {\n      saveProperties();\n    }\n  }\n\n  function makeSdkData() {\n    const sdkData = { ...platform.diagnosticSdkData };\n    if (config.wrapperName) {\n      sdkData.wrapperName = config.wrapperName;\n    }\n    if (config.wrapperVersion) {\n      sdkData.wrapperVersion = config.wrapperVersion;\n    }\n    return sdkData;\n  }\n\n  function makeConfigData() {\n    const configData = {\n      customBaseURI: config.baseUrl !== baseOptionDefs.baseUrl.default,\n      customStreamURI: config.streamUrl !== baseOptionDefs.streamUrl.default,\n      customEventsURI: config.eventsUrl !== baseOptionDefs.eventsUrl.default,\n      eventsCapacity: config.eventCapacity,\n      eventsFlushIntervalMillis: config.flushInterval,\n      reconnectTimeMillis: config.streamReconnectDelay,\n      streamingDisabled: !streamingEnabled,\n      allAttributesPrivate: !!config.allAttributesPrivate,\n      inlineUsersInEvents: !!config.inlineUsersInEvents,\n      diagnosticRecordingIntervalMillis: config.diagnosticRecordingInterval,\n      // The following extra properties are only provided by client-side JS SDKs:\n      usingSecureMode: !!config.hash,\n      bootstrapMode: !!config.bootstrap,\n      fetchGoalsDisabled: !config.fetchGoals,\n      allowFrequentDuplicateEvents: !!config.allowFrequentDuplicateEvents,\n      sendEventsOnlyForVariation: !!config.sendEventsOnlyForVariation,\n    };\n    // Client-side JS SDKs do not have the following properties which other SDKs have:\n    // connectTimeoutMillis\n    // pollingIntervalMillis\n    // samplingInterval\n    // socketTimeoutMillis\n    // startWaitMillis\n    // userKeysCapacity\n    // userKeysFlushIntervalMillis\n    // usingProxy\n    // usingProxyAuthenticator\n    // usingRelayDaemon\n\n    return configData;\n  }\n\n  // Called when the SDK is starting up. Either send an init event immediately, or, in the alternate\n  // mode, check for cached local storage properties and send an event only if we haven't done so\n  // recently.\n  manager.start = () => {\n    if (combinedMode) {\n      loadProperties(localStorageAvailable => {\n        if (localStorageAvailable) {\n          const nextEventTime = (eventSentTime || 0) + periodicInterval;\n          const timeNow = new Date().getTime();\n          if (timeNow >= nextEventTime) {\n            sendPeriodicEvent();\n          } else {\n            periodicTimer = setTimeout(sendPeriodicEvent, nextEventTime - timeNow);\n          }\n        } else {\n          // We don't have the ability to cache anything in local storage, so we don't know if we\n          // recently sent an event before this page load, but we would still prefer not to send one\n          // on *every* page load. So, as a rough heuristic, we'll decide semi-randomly.\n          if (Math.floor(Math.random() * initialEventSamplingInterval) === 0) {\n            sendPeriodicEvent();\n          } else {\n            periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n          }\n        }\n      });\n    } else {\n      sendDiagnosticEvent(createInitEvent());\n      periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n    }\n  };\n\n  manager.stop = () => {\n    periodicTimer && clearTimeout(periodicTimer);\n  };\n\n  // Called when streaming mode is turned on or off dynamically.\n  manager.setStreaming = enabled => {\n    streamingEnabled = enabled;\n  };\n\n  return manager;\n}\n\nmodule.exports = {\n  DiagnosticId,\n  DiagnosticsAccumulator,\n  DiagnosticsManager,\n};\n","// Default implementation of our internal logging interface, which writes messages to the console.\n// If no minimum level is specified, all messages will be logged. Setting the level to \"none\"\n// disables all logging.\n\nexport default function createConsoleLogger(level, maybePrefix) {\n  const allLevels = ['debug', 'info', 'warn', 'error'];\n  let prefix;\n  if (maybePrefix !== null && maybePrefix !== undefined) {\n    prefix = maybePrefix === '' ? '' : maybePrefix + ' ';\n  } else {\n    prefix = 'LD: ';\n  }\n  let minLevelIndex = 0;\n  if (level) {\n    if (level === 'none') {\n      minLevelIndex = 100;\n    } else {\n      minLevelIndex = allLevels.indexOf(level);\n    }\n  }\n\n  const logger = {};\n\n  function log(levelIndex, outputFn, msg) {\n    if (levelIndex >= minLevelIndex) {\n      const levelName = levelIndex < allLevels.length ? allLevels[levelIndex] : '?';\n      outputFn(prefix + '[' + levelName + '] ' + msg);\n    }\n  }\n\n  logger.debug = msg => log(0, console.log, msg); // eslint-disable-line no-console\n  logger.info = msg => log(1, console.info, msg); // eslint-disable-line no-console\n  logger.warn = msg => log(2, console.warn, msg); // eslint-disable-line no-console\n  logger.error = msg => log(3, console.error, msg); // eslint-disable-line no-console\n\n  return logger;\n}\n","import EventProcessor from './EventProcessor';\nimport EventEmitter from './EventEmitter';\nimport EventSender from './EventSender';\nimport InitializationStateTracker from './InitializationState';\nimport Store from './Store';\nimport Stream from './Stream';\nimport Requestor from './Requestor';\nimport Identity from './Identity';\nimport UserValidator from './UserValidator';\nimport * as configuration from './configuration';\nimport * as diagnostics from './diagnosticEvents';\nimport createConsoleLogger from './consoleLogger';\nimport * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\n\nconst changeEvent = 'change';\nconst internalChangeEvent = 'internal-change';\n\n// This is called by the per-platform initialize functions to create the base client object that we\n// may also extend with additional behavior. It returns an object with these properties:\n//   client: the actual client object\n//   options: the configuration (after any appropriate defaults have been applied)\n// If we need to give the platform-specific clients access to any internals here, we should add those\n// as properties of the return object, not public properties of the client.\n//\n// For definitions of the API in the platform object, see stubPlatform.js in the test code.\n\nexport function initialize(env, user, specifiedOptions, platform, extraOptionDefs) {\n  const logger = createLogger();\n  const emitter = EventEmitter(logger);\n  const initializationStateTracker = InitializationStateTracker(emitter);\n  const options = configuration.validate(specifiedOptions, emitter, extraOptionDefs, logger);\n  const sendEvents = options.sendEvents;\n  let environment = env;\n  let hash = options.hash;\n\n  const eventSender = EventSender(platform, environment, options);\n\n  const diagnosticsEnabled = options.sendEvents && !options.diagnosticOptOut;\n  const diagnosticId = diagnosticsEnabled ? diagnostics.DiagnosticId(environment) : null;\n  const diagnosticsAccumulator = diagnosticsEnabled ? diagnostics.DiagnosticsAccumulator(new Date().getTime()) : null;\n  const diagnosticsManager = diagnosticsEnabled\n    ? diagnostics.DiagnosticsManager(platform, diagnosticsAccumulator, eventSender, environment, options, diagnosticId)\n    : null;\n  if (diagnosticsManager) {\n    diagnosticsManager.start();\n  }\n\n  const stream = Stream(platform, options, environment, diagnosticsAccumulator);\n\n  const events =\n    options.eventProcessor ||\n    EventProcessor(platform, options, environment, diagnosticsAccumulator, emitter, eventSender);\n\n  const requestor = Requestor(platform, options, environment);\n\n  const seenRequests = {};\n  let flags = {};\n  let useLocalStorage;\n  let streamActive;\n  let streamForcedState = options.streaming;\n  let subscribedToChangeEvents;\n  let inited = false;\n  let closed = false;\n  let firstEvent = true;\n\n  // The \"stateProvider\" object is used in the Electron SDK, to allow one client instance to take partial\n  // control of another. If present, it has the following contract:\n  // - getInitialState() returns the initial client state if it is already available. The state is an\n  //   object whose properties are \"environment\", \"user\", and \"flags\".\n  // - on(\"init\", listener) triggers an event when the initial client state becomes available, passing\n  //   the state object to the listener.\n  // - on(\"update\", listener) triggers an event when flag values change and/or the current user changes.\n  //   The parameter is an object that *may* contain \"user\" and/or \"flags\".\n  // - enqueueEvent(event) accepts an analytics event object and returns true if the stateProvider will\n  //   be responsible for delivering it, or false if we still should deliver it ourselves.\n  const stateProvider = options.stateProvider;\n\n  const ident = Identity(null, sendIdentifyEvent);\n  const userValidator = UserValidator(platform.localStorage, logger);\n  let store;\n  if (platform.localStorage) {\n    store = new Store(platform.localStorage, environment, hash, ident, logger);\n  }\n\n  function createLogger() {\n    if (specifiedOptions && specifiedOptions.logger) {\n      return specifiedOptions.logger;\n    }\n    return (extraOptionDefs && extraOptionDefs.logger && extraOptionDefs.logger.default) || createConsoleLogger('warn');\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      logger.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      logger.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !closed && !platform.isDoNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!environment) {\n      // We're in paired mode and haven't been initialized with an environment or user yet\n      return;\n    }\n    if (stateProvider && stateProvider.enqueueEvent && stateProvider.enqueueEvent(event)) {\n      return; // it'll be handled elsewhere\n    }\n    if (!event.user) {\n      if (firstEvent) {\n        logger.warn(messages.eventWithoutUser());\n        firstEvent = false;\n      }\n      return;\n    }\n    firstEvent = false;\n    if (shouldEnqueueEvent()) {\n      logger.debug(messages.debugEnqueueingEvent(event.kind));\n      events.enqueue(event);\n    }\n  }\n\n  function sendIdentifyEvent(user) {\n    if (stateProvider) {\n      // In paired mode, the other client is responsible for sending identify events\n      return;\n    }\n    if (user) {\n      enqueueEvent({\n        kind: 'identify',\n        key: user.key,\n        user: user,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  function sendFlagEvent(key, detail, defaultValue, includeReason) {\n    const user = ident.getUser();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n    if (!options.allowFrequentDuplicateEvents) {\n      const cacheKey = JSON.stringify(value) + (user && user.key ? user.key : '') + key; // see below\n      const cached = seenRequests[cacheKey];\n      // cache TTL is five minutes\n      if (cached && now - cached < 300000) {\n        return;\n      }\n      seenRequests[cacheKey] = now;\n    }\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      user: user,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n    };\n    const flag = flags[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n    if ((includeReason || (flag && flag.trackReason)) && detail) {\n      event.reason = detail.reason;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function identify(user, newHash, onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve({}), onDone);\n    }\n    if (stateProvider) {\n      // We're being controlled by another client instance, so only that instance is allowed to change the user\n      logger.warn(messages.identifyDisabled());\n      return utils.wrapPromiseCallback(Promise.resolve(utils.transformVersionedValuesToValues(flags)), onDone);\n    }\n    const clearFirst = useLocalStorage && store ? store.clearFlags() : Promise.resolve();\n    return utils.wrapPromiseCallback(\n      clearFirst\n        .then(() => userValidator.validateUser(user))\n        .then(realUser =>\n          requestor\n            .fetchFlagSettings(realUser, newHash)\n            // the following then() is nested within this one so we can use realUser from the previous closure\n            .then(requestedFlags => {\n              const flagValueMap = utils.transformVersionedValuesToValues(requestedFlags);\n              ident.setUser(realUser);\n              hash = newHash;\n              if (requestedFlags) {\n                return replaceAllFlags(requestedFlags).then(() => flagValueMap);\n              } else {\n                return flagValueMap;\n              }\n            })\n        )\n        .then(flagValueMap => {\n          if (streamActive) {\n            connectStream();\n          }\n          return flagValueMap;\n        })\n        .catch(err => {\n          emitter.maybeReportError(err);\n          return Promise.reject(err);\n        }),\n      onDone\n    );\n  }\n\n  function getUser() {\n    return ident.getUser();\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(sendEvents ? events.flush() : Promise.resolve(), onDone);\n  }\n\n  function variation(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true, false).value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true, true);\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent, includeReasonInEvent) {\n    let detail;\n\n    if (flags && utils.objectHasOwnProperty(flags, key) && flags[key] && !flags[key].deleted) {\n      const flag = flags[key];\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      sendFlagEvent(key, detail, defaultValue, includeReasonInEvent);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function allFlags() {\n    const results = {};\n\n    if (!flags) {\n      return results;\n    }\n\n    for (const key in flags) {\n      if (utils.objectHasOwnProperty(flags, key)) {\n        results[key] = variationDetailInternal(key, null, !options.sendEventsOnlyForVariation).value;\n      }\n    }\n\n    return results;\n  }\n\n  function track(key, data, metricValue) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n\n    if (platform.customEventFilter && !platform.customEventFilter(key)) {\n      logger.warn(messages.unknownCustomEventKey(key));\n    }\n\n    const e = {\n      kind: 'custom',\n      key: key,\n      user: ident.getUser(),\n      url: platform.getCurrentUrl(),\n      creationDate: new Date().getTime(),\n    };\n    // Note, check specifically for null/undefined because it is legal to set these fields to a falsey value.\n    if (data !== null && data !== undefined) {\n      e.data = data;\n    }\n    if (metricValue !== null && metricValue !== undefined) {\n      e.metricValue = metricValue;\n    }\n    enqueueEvent(e);\n  }\n\n  function connectStream() {\n    streamActive = true;\n    if (!ident.getUser()) {\n      return;\n    }\n    stream.connect(ident.getUser(), hash, {\n      ping: function() {\n        logger.debug(messages.debugStreamPing());\n        requestor\n          .fetchFlagSettings(ident.getUser(), hash)\n          .then(requestedFlags => replaceAllFlags(requestedFlags || {}))\n          .catch(err => {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          });\n      },\n      put: function(e) {\n        const data = JSON.parse(e.data);\n        logger.debug(messages.debugStreamPut());\n        replaceAllFlags(data); // don't wait for this Promise to be resolved\n      },\n      patch: function(e) {\n        const data = JSON.parse(e.data);\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          logger.debug(messages.debugStreamPatch(data.key));\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamPatchIgnored(data.key));\n        }\n      },\n      delete: function(e) {\n        const data = JSON.parse(e.data);\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          logger.debug(messages.debugStreamDelete(data.key));\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamDeleteIgnored(data.key));\n        }\n      },\n    });\n  }\n\n  function disconnectStream() {\n    if (streamActive) {\n      stream.disconnect();\n      streamActive = false;\n    }\n  }\n\n  // Returns a Promise which will be resolved when we have completely updated the internal flags state,\n  // dispatched all change events, and updated local storage if appropriate. This Promise is guaranteed\n  // never to have an unhandled rejection.\n  function replaceAllFlags(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return Promise.resolve();\n    }\n\n    for (const key in flags) {\n      if (utils.objectHasOwnProperty(flags, key) && flags[key]) {\n        if (newFlags[key] && !utils.deepEquals(newFlags[key].value, flags[key].value)) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (utils.objectHasOwnProperty(newFlags, key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flags = { ...newFlags };\n    return handleFlagChanges(changes).catch(() => {}); // swallow any exceptions from this Promise\n  }\n\n  // Returns a Promise which will be resolved when we have dispatched all change events and updated\n  // local storage if appropriate.\n  function handleFlagChanges(changes) {\n    const keys = Object.keys(changes);\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n      emitter.emit(internalChangeEvent, flags);\n\n      // By default, we send feature evaluation events whenever we have received new flag values -\n      // the client has in effect evaluated these flags just by receiving them. This can be suppressed\n      // by setting \"sendEventsOnlyForVariation\". Also, if we have a stateProvider, we don't send these\n      // events because we assume they have already been sent by the other client that gave us the flags\n      // (when it received them in the first place).\n      if (!options.sendEventsOnlyForVariation && !stateProvider) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n\n    if (useLocalStorage && store) {\n      return store.saveFlags(flags).catch(() => null); // disregard errors\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function on(event, handler, context) {\n    if (isChangeEventKey(event)) {\n      subscribedToChangeEvents = true;\n      if (inited) {\n        updateStreamingState();\n      }\n      emitter.on(event, handler, context);\n    } else {\n      emitter.on(...arguments);\n    }\n  }\n\n  function off(event) {\n    emitter.off(...arguments);\n    if (isChangeEventKey(event)) {\n      let haveListeners = false;\n      emitter.getEvents().forEach(key => {\n        if (isChangeEventKey(key) && emitter.getEventListenerCount(key) > 0) {\n          haveListeners = true;\n        }\n      });\n      if (!haveListeners) {\n        subscribedToChangeEvents = false;\n        if (streamActive && streamForcedState === undefined) {\n          disconnectStream();\n        }\n      }\n    }\n  }\n\n  function setStreaming(state) {\n    const newState = state === null ? undefined : state;\n    if (newState !== streamForcedState) {\n      streamForcedState = newState;\n      updateStreamingState();\n    }\n  }\n\n  function updateStreamingState() {\n    const shouldBeStreaming = streamForcedState || (subscribedToChangeEvents && streamForcedState === undefined);\n    if (shouldBeStreaming && !streamActive) {\n      connectStream();\n    } else if (!shouldBeStreaming && streamActive) {\n      disconnectStream();\n    }\n    if (diagnosticsManager) {\n      diagnosticsManager.setStreaming(shouldBeStreaming);\n    }\n  }\n\n  function isChangeEventKey(event) {\n    return event === changeEvent || event.substr(0, changeEvent.length + 1) === changeEvent + ':';\n  }\n\n  if (typeof options.bootstrap === 'string' && options.bootstrap.toUpperCase() === 'LOCALSTORAGE') {\n    if (store) {\n      useLocalStorage = true;\n    } else {\n      logger.warn(messages.localStorageUnavailable());\n    }\n  }\n\n  if (typeof options.bootstrap === 'object') {\n    // Set the flags as soon as possible before we get into any async code, so application code can read\n    // them even if the ready event has not yet fired.\n    flags = readFlagsFromBootstrap(options.bootstrap);\n  }\n\n  if (stateProvider) {\n    // The stateProvider option is used in the Electron SDK, to allow a client instance in the main process\n    // to control another client instance (i.e. this one) in the renderer process. We can't predict which\n    // one will start up first, so the initial state may already be available for us or we may have to wait\n    // to receive it.\n    const state = stateProvider.getInitialState();\n    if (state) {\n      initFromStateProvider(state);\n    } else {\n      stateProvider.on('init', initFromStateProvider);\n    }\n    stateProvider.on('update', updateFromStateProvider);\n  } else {\n    finishInit().catch(signalFailedInit);\n  }\n\n  function finishInit() {\n    if (!env) {\n      return Promise.reject(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    }\n    return userValidator.validateUser(user).then(realUser => {\n      ident.setUser(realUser);\n      if (typeof options.bootstrap === 'object') {\n        // flags have already been set earlier\n        return signalSuccessfulInit();\n      } else if (useLocalStorage) {\n        return finishInitWithLocalStorage();\n      } else {\n        return finishInitWithPolling();\n      }\n    });\n  }\n\n  function finishInitWithLocalStorage() {\n    return store\n      .loadFlags()\n      .catch(() => null) // treat an error the same as if no flags were available\n      .then(storedFlags => {\n        if (storedFlags === null || storedFlags === undefined) {\n          flags = {};\n          return requestor\n            .fetchFlagSettings(ident.getUser(), hash)\n            .then(requestedFlags => replaceAllFlags(requestedFlags || {}))\n            .then(signalSuccessfulInit)\n            .catch(err => {\n              const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n              signalFailedInit(initErr);\n            });\n        } else {\n          // We're reading the flags from local storage. Signal that we're ready,\n          // then update localStorage for the next page load. We won't signal changes or update\n          // the in-memory flags unless you subscribe for changes\n          flags = storedFlags;\n          utils.onNextTick(signalSuccessfulInit);\n\n          return requestor\n            .fetchFlagSettings(ident.getUser(), hash)\n            .then(requestedFlags => replaceAllFlags(requestedFlags))\n            .catch(err => emitter.maybeReportError(err));\n        }\n      });\n  }\n\n  function finishInitWithPolling() {\n    return requestor\n      .fetchFlagSettings(ident.getUser(), hash)\n      .then(requestedFlags => {\n        flags = requestedFlags || {};\n        // Note, we don't need to call updateSettings here because local storage and change events are not relevant\n        signalSuccessfulInit();\n      })\n      .catch(err => {\n        flags = {};\n        signalFailedInit(err);\n      });\n  }\n\n  function initFromStateProvider(state) {\n    environment = state.environment;\n    ident.setUser(state.user);\n    flags = { ...state.flags };\n    utils.onNextTick(signalSuccessfulInit);\n  }\n\n  function updateFromStateProvider(state) {\n    if (state.user) {\n      ident.setUser(state.user);\n    }\n    if (state.flags) {\n      replaceAllFlags(state.flags); // don't wait for this Promise to be resolved\n    }\n  }\n\n  function signalSuccessfulInit() {\n    logger.info(messages.clientInitialized());\n    inited = true;\n    updateStreamingState();\n    initializationStateTracker.signalSuccess();\n  }\n\n  function signalFailedInit(err) {\n    initializationStateTracker.signalFailure(err);\n  }\n\n  function start() {\n    if (sendEvents) {\n      if (diagnosticsManager) {\n        diagnosticsManager.start();\n      }\n      events.start();\n    }\n  }\n\n  function close(onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve(), onDone);\n    }\n    const finishClose = () => {\n      closed = true;\n      flags = {};\n    };\n    const p = Promise.resolve()\n      .then(() => {\n        disconnectStream();\n        if (diagnosticsManager) {\n          diagnosticsManager.stop();\n        }\n        if (sendEvents) {\n          events.stop();\n          return events.flush();\n        }\n      })\n      .then(finishClose)\n      .catch(finishClose);\n    return utils.wrapPromiseCallback(p, onDone);\n  }\n\n  function getFlagsInternal() {\n    // used by Electron integration\n    return flags;\n  }\n\n  const client = {\n    waitForInitialization: () => initializationStateTracker.getInitializationPromise(),\n    waitUntilReady: () => initializationStateTracker.getReadyPromise(),\n    identify: identify,\n    getUser: getUser,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    on: on,\n    off: off,\n    setStreaming: setStreaming,\n    flush: flush,\n    allFlags: allFlags,\n    close: close,\n  };\n\n  return {\n    client: client, // The client object containing all public methods.\n    options: options, // The validated configuration object, including all defaults.\n    emitter: emitter, // The event emitter which can be used to log errors or trigger events.\n    ident: ident, // The Identity object that manages the current user.\n    logger: logger, // The logging abstraction.\n    requestor: requestor, // The Requestor object.\n    start: start, // Starts the client once the environment is ready.\n    enqueueEvent: enqueueEvent, // Puts an analytics event in the queue, if event sending is enabled.\n    getFlagsInternal: getFlagsInternal, // Returns flag data structure with all details.\n    getEnvironmentId: () => environment, // Gets the environment ID (this may have changed since initialization, if we have a state provider)\n    internalChangeEventName: internalChangeEvent, // This event is triggered whenever we have new flag state.\n  };\n}\n\nexport const version = VERSION;\nexport { createConsoleLogger };\nexport { errors };\nexport { messages };\nexport { utils };\n"],"names":["createCustomError","name","CustomError","message","code","Error","captureStackTrace","this","constructor","prototype","LDUnexpectedResponseError","LDInvalidEnvironmentIdError","LDInvalidUserError","LDInvalidEventKeyError","LDInvalidArgumentError","LDFlagFetchError","isHttpErrorRecoverable","status","fromByteArray","lookup","revLookup","i","len","length","charCodeAt","tripletToBase64","num","encodeChunk","uint8","start","end","tmp","output","push","join","extraBytes","parts","maxChunkLength","len2","isArray","Array","keyList","Object","keys","hasProp","hasOwnProperty","equal","a","b","key","arrA","arrB","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","call","userAttrsToStringify","btoa","s","escaped","unescape","encodeURIComponent","base64","stringToBytes","base64URLEncode","replace","clone","obj","JSON","parse","stringify","deepEquals","fastDeepEqual","onNextTick","cb","setTimeout","wrapPromiseCallback","promise","callback","ret","then","value","error","Promise","reject","undefined","transformValuesToVersionedValues","flags","objectHasOwnProperty","version","transformVersionedValuesToValues","flagsState","chunkUserEventsForUrl","maxLength","events","chunk","allEvents","slice","allChunks","remainingSpace","event","shift","unshift","getLDUserAgentString","platform","userAgent","getLDHeaders","options","sendLDHeaders","h","wrapperName","wrapperVersion","extend","objects","reduce","acc","object","sanitizeUser","user","newUser","attr","String","getRandomValues","crypto","bind","window","msCrypto","rnds8","Uint8Array","module","rnds","r","Math","random","byteToHex","substr","bytesToUuid","buf","offset","bth","_nodeId","_clockseq","_lastMSecs","_lastNSecs","v1","node","clockseq","seedBytes","rng","msecs","nsecs","dt","tl","tmh","n","MAX_URL_LENGTH","EventSender","environmentId","imageUrlPath","baseHeaders","utils","httpFallbackPing","sender","sendChunk","url","isDiagnostic","usePost","jsonBody","payloadId","uuidv1","doPostRequest","canRetry","headers","httpRequest","result","errors","dateStr","header","time","serverTime","getResponseInfo","catch","resolve","sendEvents","chunks","canPost","httpAllowsPost","results","all","EventSummarizer","es","startDate","endDate","counters","summarizeEvent","kind","counterKey","variation","counterVal","count","default","creationDate","getSummary","flagsOut","empty","c","flag","counterOut","unknown","features","clearSummary","UserFilter","config","filter","allAttributesPrivate","privateAttributeNames","ignoreAttrs","custom","anonymous","allowedTopLevelAttrs","secondary","ip","country","email","firstName","lastName","avatar","filterUser","filterAttrs","props","isAttributeAllowed","userPrivateAttrs","indexOf","isPrivateAttr","filteredProps","removedAttrs","customResult","removedAttrNames","sort","privateAttrs","errorString","err","clientInitialized","docLink","clientNotReady","eventCapacityExceeded","eventWithoutUser","invalidContentType","contentType","invalidKey","localStorageUnavailable","localStorageUnavailableForUserId","networkError","e","unknownCustomEventKey","environmentNotFound","environmentNotSpecified","errorFetchingFlags","userNotSpecified","invalidUser","bootstrapOldFormat","bootstrapInvalid","deprecated","oldName","newName","httpErrorMessage","context","retryMessage","httpUnavailable","identifyDisabled","streamClosing","streamConnecting","streamError","streamReconnectDelay","unknownOption","wrongOptionType","expectedType","actualType","wrongOptionTypeBoolean","optionBelowMinimum","minimum","debugPolling","debugStreamPing","debugStreamPut","debugStreamPatch","debugStreamPatchIgnored","debugStreamDelete","debugStreamDeleteIgnored","debugEnqueueingEvent","debugPostingEvents","debugPostingDiagnosticEvent","EventProcessor","flushTimer","diagnosticsAccumulator","emitter","processor","eventSender","mainEventsUrl","eventsUrl","summarizer","userFilter","inlineUsers","inlineUsersInEvents","samplingInterval","eventCapacity","flushInterval","logger","queue","lastKnownPastTime","disabled","exceededCapacity","shouldSampleEvent","floor","addToOutbox","warn","messages","incrementDroppedEvents","enqueue","addFullEvent","addDebugEvent","trackEvents","debugEventsUntilDate","shouldDebugEvent","userKey","makeOutputEvent","debugEvent","flush","eventsToSend","summary","setEventsInLastBatch","debug","responseInfo","maybeReportError","flushTick","stop","clearTimeout","EventEmitter","on","handler","concat","off","emit","copiedHandlers","apply","arguments","getEvents","getEventListenerCount","listeningTo","console","readyEvent","successEvent","failureEvent","InitializationStateTracker","eventEmitter","succeeded","failed","failureValue","initializationPromise","readyPromise","onReady","getInitializationPromise","onSuccess","onFailure","getReadyPromise","signalSuccess","signalFailure","Store","localStorageProvider","environment","hash","ident","store","getFlagsKey","getUser","loadFlags","get","dataStr","data","schema","$schema","ex","clearFlags","saveFlags","set","clear","Stream","connectionAttemptStartTime","baseUrl","streamUrl","stream","evalUrlPrefix","useReport","withReasons","evaluationReasons","firstConnectionErrorLogged","reconnectTimeoutReference","handlers","handleError","logConnectionResult","closeConnection","tryConnect","delay","openConnection","query","eventSourceFactory","eventSourceAllowsReport","method","body","info","addEventListener","onerror","close","success","recordStreamInit","connect","newHash","newHandlers","disconnect","isConnected","eventSourceIsActive","promiseCoalescer","finallyFn","currentPromise","currentCancelFn","finalResolve","finalReject","coalescer","p","cancelFn","resultPromise","jsonContentType","getResponseError","statusText","Requestor","requestor","activeRequests","fetchJSON","endpoint","req","startsWith","addPromise","cancel","path","fetchFlagSettings","Identity","initialUser","onChange","setUser","u","ldUserIdKey","UserValidator","validateUser","userOut","cachedId","id","setCachedUserId","baseOptionDefs","streaming","type","allowFrequentDuplicateEvents","sendEventsOnlyForVariation","bootstrap","diagnosticRecordingInterval","diagnosticOptOut","stateProvider","validate","extraOptionDefs","optionDefs","deprecatedOptions","all_attributes_private","private_attribute_names","reportArgumentError","opts","typeDescForValue","t","forEach","optionDef","allowedTypes","split","require$$0","DiagnosticId","sdkKey","diagnosticId","sdkKeySuffix","substring","DiagnosticsAccumulator","startTime","dataSinceDate","droppedEvents","eventsInLastBatch","streamInits","reset","getProps","setProps","timestamp","durationMillis","DiagnosticsManager","accumulator","eventSentTime","periodicTimer","combinedMode","diagnosticUseCombinedEvent","localStorageKey","diagnosticEventsUrl","periodicInterval","streamingEnabled","manager","makeInitProperties","sdk","sdkData","diagnosticSdkData","makeSdkData","configuration","customBaseURI","customStreamURI","customEventsURI","eventsCapacity","eventsFlushIntervalMillis","reconnectTimeMillis","streamingDisabled","diagnosticRecordingIntervalMillis","usingSecureMode","bootstrapMode","fetchGoalsDisabled","fetchGoals","diagnosticPlatformData","sendDiagnosticEvent","sendPeriodicEvent","currentTime","createPeriodicEventAndReset","localStorage","saveProperties","loadProperties","localStorageAvailable","nextEventTime","timeNow","setStreaming","enabled","createConsoleLogger","level","maybePrefix","prefix","allLevels","minLevelIndex","log","levelIndex","outputFn","msg","levelName","changeEvent","internalChangeEvent","initialize","env","specifiedOptions","createLogger","initializationStateTracker","diagnosticsEnabled","diagnostics","diagnosticsManager","useLocalStorage","streamActive","subscribedToChangeEvents","eventProcessor","seenRequests","streamForcedState","inited","closed","firstEvent","enqueueEvent","userValidator","isDoNotTrack","sendFlagEvent","detail","defaultValue","includeReason","now","cacheKey","cached","variationIndex","flagVersion","trackReason","reason","variationDetailInternal","sendEvent","includeReasonInEvent","deleted","getFlagDetail","errorKind","connectStream","ping","requestedFlags","replaceAllFlags","put","patch","oldFlag","mods","newFlag","newDetail","previous","current","handleFlagChanges","delete","disconnectStream","newFlags","changes","changeEventParams","updateStreamingState","shouldBeStreaming","isChangeEventKey","toUpperCase","_typeof","metadataKey","metadata","readFlagsFromBootstrap","state","getInitialState","initFromStateProvider","realUser","signalSuccessfulInit","storedFlags","signalFailedInit","client","waitForInitialization","waitUntilReady","identify","onDone","flagValueMap","variationDetail","track","metricValue","customEventFilter","getCurrentUrl","haveListeners","newState","allFlags","finishClose","getFlagsInternal","getEnvironmentId","internalChangeEventName"],"mappings":"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"}